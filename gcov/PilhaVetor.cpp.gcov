        -:    0:Source:PilhaVetor.cpp
        -:    0:Graph:../bin/obj/PilhaVetor.gcno
        -:    0:Data:../bin/obj/PilhaVetor.gcda
        -:    0:Runs:4
        -:    0:Programs:4
        -:    1:#include "../include/PilhaVetor.hpp"
        -:    2:#include <stdlib.h> // malloc()
        -:    3:#include <new>      // bad_alloc()
        -:    4:#include <string.h> // memcpy()
        -:    5:
       14:    6:_PilhaVetor::_base::_base(int elementSize, int capacity) {
       14:    7:    _elementSize = elementSize;
       14:    8:    setCapacity(capacity);
       14:    9:}
        -:   10:
       28:   11:_PilhaVetor::_base::~_base() {
       14:   12:    free(_data);
        -:   13:    _data == nullptr;
       14:   14:}
        -:   15:
      134:   16:bool _PilhaVetor::_base::push(void* data) {
      134:   17:    if (_elementCount +1 > _capacity)
        8:   18:        return false;
      130:   19:    _elementCount++;
      130:   20:    memcpy(top(), data, _elementSize);
      130:   21:}
        -:   22:
      132:   23:void* _PilhaVetor::_base::pop() {
      132:   24:    void* ptr = top();
      132:   25:    if (ptr != nullptr)
      130:   26:        _elementCount--;
      132:   27:    return ptr;
        -:   28:}
        -:   29:
      278:   30:void* _PilhaVetor::_base::top() {
      278:   31:    if (_elementCount < 1)
        6:   32:        return nullptr;
      272:   33:    return (void*)(_data + (_elementCount-1) * _elementSize);
        -:   34:}
        -:   35:
       34:   36:int _PilhaVetor::_base::elementCount() {
       34:   37:    return _elementCount;
        -:   38:}
        -:   39:
       34:   40:int _PilhaVetor::_base::getCapacity() {
       34:   41:    if (_data != nullptr)
       34:   42:        return _capacity;
    #####:   43:    else return 0;
        -:   44:}
        -:   45:
       20:   46:bool _PilhaVetor::_base::setCapacity(int capacity) {
        -:   47:    // Capacidade de vetor nÃ£o pode ser nula
       20:   48:    if (capacity < 0)
    #####:   49:        return false;
        -:   50:
        -:   51:    // Capacidade tem que suportar todos os elementos atuais
       20:   52:    if (capacity < _elementCount)
        2:   53:        return false;
        -:   54:
       18:   55:    if (_data != nullptr && _capacity_allocated < capacity) {
        6:   56:        _capacity = capacity;
        6:   57:        return true;
        -:   58:    }
        -:   59:
       12:   60:    void* newdata = malloc(_elementSize * capacity);
        -:   61:
       12:   62:    if (newdata == nullptr) 
    #####:   63:        throw std::bad_alloc();
        -:   64:
       12:   65:    if (_data != nullptr) {
       10:   66:        if (_elementCount > 0)
    #####:   67:            memcpy(newdata, _data, _elementSize * _elementCount);
       10:   68:        free(_data);
        -:   69:    }
        -:   70:
       12:   71:    _data = newdata;
       12:   72:    _capacity = capacity;
       12:   73:    _capacity_allocated = capacity;
        -:   74:
       12:   75:    return true;
        -:   76:}
